## 常用算法

[目录](#)
* [常见排序算法](#常见排序算法)

### 常见排序算法
```
    常见的排序主要有以下几种：
    1、插入排序：直接插入、二分法、希尔排序
    2、选择排序：选择排序、堆排序
    3、交换排序：冒泡排序、快速排序
    4、归并排序
    5、基数排序
```
> 对比每种排序的性能

|排序方法|时间复杂度（平均）|时间复杂度（最坏)|时间复杂度（最好)|空间复杂度|稳定性|复杂性|
|:-----|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|直接插入排序|	O(n2)		|O(n2)		|O(n2)		|O(n2)		|O(n)		|O(n)		|O(1)		|O(1)	|稳定	简单       |
|希尔排序	|	O(nlog2n)	|O(nlog2n)	|O(n2)		|O(n2)		|O(n)		|O(n)		|O(1)		|O(1)	|不稳定	较复杂     |
|直接选择排序|	O(n2)		|O(n2)		|O(n2)		|O(n2)		|O(n2)		|O(n2)		|O(1)		|O(1)	|不稳定	简单       |
|堆排序		|	O(nlog2n)	|O(nlog2n)	|O(nlog2n)	|O(nlog2n)	|O(nlog2n)	|O(nlog2n)	|O(1)		|O(1)	|不稳定	较复杂     |
|冒泡排序	|	O(n2)		|O(n2)		|O(n2)		|O(n2)		|O(n)		|O(n)		|O(1)		|O(1)	|稳定	简单       |
|快速排序	|	O(nlog2n)	|O(nlog2n)	|O(n2)		|O(n2)		|O(nlog2n)	|O(nlog2n)	|O(nlog2n)	|O(nlog2n)	|不稳定	|较复杂|
|归并排序	|	O(nlog2n)	|O(nlog2n)	|O(nlog2n)	|O(nlog2n)	|O(nlog2n)	|O(nlog2n)	|O(n)		|O(n)	|稳定	|较复杂    |
|基数排序	|	O(d(n+r))	|O(d(n+r))	|O(d(n+r))	|O(d(n+r))	|O(d(n+r))	|O(d(n+r))	|O(n+r)		|O(n+r)	|稳定	|较复杂    |

+ 直接插入排序（从后向前找到合适位置后插入）

> 基本思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。核心代码如下:<br />
```java
    //直接排序
    for (int i = 0; i < a.length; i++) {
        //待插入元素
        int temp = a[i];
        int j;
        
        for (j = i - 1; j >=0 ; j--) {
            //若后面的值小于前一位的值，则和前一位的值替换,直到插入到最合适的位置
            if (a[j] > temp){
                a[j+1] = a[j];
            }else{
                break;
            }
        }
        a[j+1] = temp;
    }
```
> 算法图解<br />
![](https://github.com/pekeyliu/AboutArchitecture/blob/master/Algorithms/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif)

+ 二分法插入排序
> 基本思想：二分法插入排序的思想和直接插入一样，只是找合适的插入位置的方式不同，这里是按二分法找到合适的位置，可以减少比较的次数。核心代码如下：

```java
    //二分法排序
    for (int i = 0; i < a.length; i++) {
        int temp = a[i];
        int left = 0;
        int right = i - 1;
        int mid = 0;
        //通过二分法来快速查找temp元素应插入的位置
        while (left <= right){
            mid = (left + right)/2;
            if (temp < a[mid]){
                right = mid - 1;
            }else {
                left = mid + 1;
            }
        }
        //将大于temp元素的值统一向后移动一位
        for (int j = i-1; j >= left ; j--) {
            a[j+1] = a[j];
        }
        //在查找到合适的位置插入temp元素
        if (left != temp){
            a[left] = temp;
        }
    }
```
+ 希尔排序
> 基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2<br/>
```java
    // 希尔排序
    int d = a.length;
    while (true) {
        d = d / 3;  //3个分为一组
        for (int x = 0; x < d; x++) {
            for (int i = x + d; i < a.length; i = i + d) {
                int temp = a[i];
                int j;
                for (j = i - d; j >= 0 && a[j] > temp; j = j - d) {
                    a[j + d] = a[j];
                }
                a[j + d] = temp;
            }
        }
        if (d == 1) {
            break;
        }
    }
```
+ 直接选择排序
> 基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。
```java
    // 直接选择排序
    for (int i = 0; i < a.length; i++) {
        int min = a[i];
        int n = i; // 最小数的索引
        for (int j = i + 1; j < a.length; j++) {
            if (a[j] < min) { // 找出最小的数
                min = a[j];
                n = j;
            }
        }
        a[n] = a[i];
        a[i] = min;
    }
```

+ 堆排序
> 堆排序是一种树形选择排序，是对直接选择排序的有效改进。<br />
堆的定义下：具有n个元素的序列 （h1,h2,…,hn),当且仅当满足（hi>=h2i,hi>=2i+1）或（hi<=h2i,hi<=2i+1） (i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。<br />
思想：初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。

